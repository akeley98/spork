\magicSubsection{Checks on Mutate}{sec:ChecksOnMutate}

Mutate accesses impose requirements on both the read and mutate visibility record sets, with the requirements conditional on whether the mutate is write-only (Section~\ref{sec:InstrMemoryAccess}) and/or atomic (Section~\ref{sec:AtomicInstr}).

For each array element $x[n^*]$ that is mutated as part of a write, reduce, or instr call statement,
\begin{itemize}
  \item let $g^* = g_{s^\#}(\iota, \sigma)$ be the thread collective assigned to execute the statement (Section~\ref{sec:SyncSemanticsThreadMapping})
  \item let $q^*$ be the \myKeyA{extended timeline set} (Section~\ref{sec:InstrTL})
  \item let $t$ be the convergence flag (Section~\ref{sec:InstrConvergentAccess})
  \item let $\mathsf{vf}: \mathsf{VF}$ (def~\ref{sec:gVisFlag}) be $\mathsf{VF_{temp}}$ if the access is non-atomic write-only, $\mathsf{VF_{full}}$ if the access is non-atomic read-write, and $\mathsf{VF_{atom}}$ if the access is atomic.
\end{itemize}
Require that
\begin{align*}
    & \forall r \in \rho(x, n^*).r, \mathsf{CheckVisRecord}(t, g^*, q^*, \mathsf{VF_{temp}}, r) \\
    & \forall r \in \rho(x, n^*).m, \mathsf{CheckVisRecord}(t, g^*, q^*, \mathsf{vf}, r)
\end{align*}
If the above is not true, the abstract machine enters the error condition.
Otherwise, this step causes no state changes, but the abstract machine continues on to the changes specified in Section~\ref{sec:VisRecordCreation}.

