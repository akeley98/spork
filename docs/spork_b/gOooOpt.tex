\magicSubsection{Out-of-order Non-convergent Abstract Machine Optimization}{sec:gOooOpt}

Alteration of abstract machine semantics for out-of-order, non-convergent accesses as implemented by \lighttt{camspork} (def~\ref{sec:gCamspork}).

Suppose that in a given proc, for a given qualitative timeline $q$ (def~\ref{sec:gQualTL}), we know that the collective tiling (Section~\ref{sec:CollTiling}) for all \lighttt{Fence} and \lighttt{Arrive} statements that contain $q$ in their first synchronization timeline $\tau_s^\mathrm{pre}$ (Section~\ref{sec:gSyncTL}) are ``aligned'' so that, for a certain value $\mathsf{TAG}_q: \mathbb{N}$, any thread collective $\mu$ (def~\ref{sec:gThreadCollective}) generated by the collective tiling will always consist of aligned groups of $\mathsf{TAG}_q$-many threads, i.e.
\begin{gather*}
    \lfloor n_0 / \mathsf{TAG}_q \rfloor = \lfloor n_1 / \mathsf{TAG}_q \rfloor
    \implies
    ((\iota, n_0) \in \mu \iff (\iota, n_1) \in \mu)
\end{gather*}
Suppose further that $\mathsf{TAG}_q$ always divides the number of threads per task.\footnote{This extra requirement is needed due to how camspork linearizes the (task-id, local-thread-index) pair.}
The maximum power-of-2 $\mathsf{TAG}_q$ that satisfies these properties for $q$ is the \myKeyA{thread access granularity} for $q$.

With this optimization, the visibility sets added for out-of-order, non-convergent accesses (Section~\ref{sec:VisRecordCreation}) have their visibility sets $s$ replaced with $s'$, where
\begin{align*}
    & s' = \cup_{((\iota, n), q, v) \in s} \{ \iota \} \times \mathsf{alignedGroup}(n, \mathsf{TAG}_q) \times \{ q \} \times \{ v \} \\
    & \text{where } \mathsf{alignedGroup}(n, \mathsf{TAG}_q) = \{ n_b + 0, n_b + 1, ... n_b + \mathsf{TAG}_q - 1 \} \\
    & \text{and where } n_b = \lfloor n / \mathsf{TAG}_q \rfloor \mathsf{TAG}_q
\end{align*}
By the official abstract machine semantics, there's one \textsf{VisRecord} added for each thread in the non-convergent case, so this optimization drastically cuts down the number of unique \textsf{VisRecord} instances in the \lighttt{camspork} memoization table.

Note that $n \in \mathsf{alignedGroup}(n, \mathsf{TAG}_q)$ and all pairs in $\mathsf{alignedGroup}(n, \mathsf{TAG}_q)$ satisfy the antecedent of the above alignment property.
This optimization will not change whether a program passes sync-check or not, because out-of-order accesses lead only to timeline signatures with visibility flag $\mathsf{VF_{issue}}$ being added (Section~\ref{sec:VisRecordCreation}), and those are only used in the witness function (Section~\ref{sec:Witness}) for \lighttt{Fence} and \lighttt{Arrive}.
If the thread collective for the witness function always satisfies the above alignment property, then the added timeline signatures won't affect the output of that function.

Although this optimization is confusing (and changes the semantics visible to the end user for error messages), it's implemented anyway since it's the difference between sub-second runtimes and multi-minute runtimes.
This optimization is not valid for non-out-of-order access, because such accesses also add timeline signatures with $\mathsf{VF_{full}}$, and that has uses beyond just the witness function.

TODO on the other hand, this seems applicable to the convergent case as well.

% >P

