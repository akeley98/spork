\magicSubsection{Intended Usage Patterns -- Access After Synchronization}{sec:AccessAfterSync}

\begin{equation*}
    \texttt{Await(\codecomment{...}, $\tau_s^\mathrm{post}$, \codecomment{...})|Fence(\codecomment{...}, $\tau_s^\mathrm{post}$)} \to \texttt{Read|Mutate}
\end{equation*}

A dependency edge forms between an \lighttt{Await} or \lighttt{Fence} statement instance and a subsequent read or mutate when there is a thread in common executing the two, and any of
\begin{itemize}
  \item The access is a read, or a read-write mutate (Section~\ref{sec:InstrMemoryAccess}), and there is a qualitative timeline $q$ in common between $\tau_s^\mathrm{post}.\mathrm{full}$ and the extended qualitative timelines (Section~\ref{sec:InstrTL}) of the read or mutate.
  \item The access is a write-only mutate (Section~\ref{sec:InstrMemoryAccess}), and there is a qualitative timeline $q$ in common between $\tau_s^\mathrm{post}.\mathrm{temp}$ and the extended qualitative timelines (Section~\ref{sec:InstrTL}) of the mutate.
  This is ``temporal-only'' synchronization, which may elide proxy fences.
  \item The ``access'' is as a result of freeing shared memory (Section~\ref{sec:ChecksOnFree}).
  This is needed to safely alias future allocations onto the freed physical SMEM, whose effects we overapproximate as a non-convergent write-only mutate by each thread in the cluster.
\end{itemize}

The sychronization timeline $\tau_s^\mathrm{post}$ (def~\ref{sec:gSyncTL}) to use varies depending on the instruction issuing the read or mutate:
\begin{itemize}
  \item \lighttt{cuda\_in\_order} if the following reads and mutates are only issued by generic proxy instructions: non-async CUDA instructions and sm\_80 non-bulk \lighttt{cp.async}.
  These instructions include \lighttt{cuda\_in\_order\_ram\_qual} (def~\ref{sec:gQualTL}) in their extended timeline set for non-register parameters.
  \item \lighttt{cuda\_generic\_and\_async\_proxy} if any async proxy instructions are involved (TMA, wgmma, tcgen05); these instructions include \lighttt{cuda\_async\_proxy\_retired} (def~\ref{sec:gQualTL}) in their extended timeline set for non-register parameters.
  \item \lighttt{cuda\_temporal} may also be used if only temporal-only synchronization is required.
\end{itemize}
As a special case, \lighttt{Fence(wgmma\_fence\_1, wgmma\_fence\_2)} at \lighttt{cuda\_warpgroup}-scope (def~\ref{sec:gCollUnit}) should be used before any accesses to wgmma registers, even if no prior access occurs (this is \emph{not} enforced by sync-check, but will result in a ptxas warning and suboptimal CUDA code if violated).

With $(\iota, n)$ denoting a thread in common, and with
\begin{itemize}
    \item $\mathsf{vf} = \mathsf{VF_{temp}}$ (def~\ref{sec:gVisFlag}) and $q$ denoting a qualitative timeline in common to $\tau_s^\mathrm{post}.\mathrm{temp}$ and the extended timeline set, in the case of temporal-only synchronization.
    \item $\mathsf{vf} = \mathsf{VF_{full}}$ for non-atomic acceses or $\mathsf{vf} = \mathsf{VF_{atom}}$ for atomics, and $q$ denoting a qualitative timeline in common to $\tau_s^\mathrm{post}.\mathrm{full}$ and the extended timeline set, in the other case.
\end{itemize}
this pattern is implemented in sync-check by the augment step (Section~\ref{sec:Augment}) adding the timeline signature $((\iota, n), q, \mathsf{vf})$ to visibility records, which satisfy the checking requirements for the subsequent read (Section~\ref{sec:ChecksOnRead}) or mutate (Section~\ref{sec:ChecksOnMutate}).


