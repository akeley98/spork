% xelatex </dev/null SpecialWindow.tex
\input{whitepaper_common.tex}

\begin{document}
\myTitle{SpecialWindow: EXO GPU Abstraction for CUtensorMap}

\mySub{Proposal Summary}

We need to model \lighttt{CUtensorMap} in Exo, which is a descriptor needed for using the H100's TMA feature.
This 128-byte blob is non-trivial to initialize, and needs to be initialized on the CPU, prior to its usage in the CUDA kernel
(i.e. we can't create it at the call site of a TMA instruction).

The CUtensorMap contains
\begin{itemize}
  \item The address of the tensor in global memory
  \item The shape and stride of the global tensor
  \item The size of the box in shared memory (but not the shared memory address)
  \item The swizzle mode
\end{itemize}

The CUtensorMap can only be used on the device for copies between global and shared memory of the exact box size specified, and with the shared memory swizzled as specified.

We want to model the restrictions of CUtensorMap in the Exo type system, and we want to have the construction of a CUtensorMap be explicit in the object code.

\begin{itemize}
  \item We need to create a concept of (special) window type, similar to memory type.
  \item This is represented by \lighttt{SpecialWindow} and \lighttt{Memory} respectively, both inheriting from \lighttt{MemWin}.
    \lighttt{MemWin} can appear in most places \lighttt{Memory} appears today.
    Allocations must still use \lighttt{Memory}.
    Windows can be created either using the underlying tensor's \lighttt{Memory} type or with a ``compatible'' \lighttt{SpecialWindow} (TODO define ``compatible'').
  \item These types need to be parameterizable with the swizzle type and box size, e.g. \lighttt{CUtensorMapWindow(128, 192, 256)} could mean 128 byte swizzle, $192 \times 256$ box size.
    This is needed for the memory/window type checking with TMA instrs to work correctly.
  \item Proposal 1: Extend \lighttt{WindowStmt} with a window type annotation. Something like:
  \begin{itemize}
    \item \lighttt{\blueBox{special\_window\_name} = \greenBox{original\_gmem}[slice...] @ CUtensorMapWindow(...)}
    \item \lighttt{tma\_instr(\blueBox{special\_window\_name}[...], smem[...])}
    \item \lighttt{non\_tma\_instr(\greenBox{original\_gmem}[slice...], ...)}
  \end{itemize}
  This creates a new \lighttt{Sym} (Exo object code name) which the user must sub-window for TMA instructions.
  \item Proposal 2: Add a new ``construct special window'' statement that takes a tensor and a \lighttt{SpecialWindow} type as input.
  Remove \lighttt{WindowStmt}; windows can only be constructed at the call site of a proc/instr (\lighttt{WindowExpr}).
  One Exo \lighttt{Sym} may refer to multiple C symbols (window structs), disambiguated by explicit special window type.
  A window expression by default uses the original memory type; annotate with a \lighttt{SpecialWindow} type to override.
  \begin{itemize}
    \item \lighttt{\greenBox{original\_gmem} \blueBox{@ CUtensorMapWindow(...)}  \# special window; syntax TBD}
    \item \lighttt{tma\_instr(\greenBox{original\_gmem}[slice...] \blueBox{@ CUtensorMapWindow(...)}, smem[...])}
    \item \lighttt{non\_tma\_instr(\greenBox{original\_gmem}[slice...], ...)}
  \end{itemize}
  It's an error at code lowering time if the annotation requests a special window that was not constructed.
\end{itemize}

\filbreak
\mySub{Background: WindowStmt}

Exo currently supports ``window statements'' with the following syntax:

\lighttt{window\_name = tensor\_name[slice\_lo:slice\_hi, etc.]}

which creates an alias to a sub-tile of the tensor.
This is implemented with the \lighttt{LoopIR.WindowStmt} node.
This window is alive throughout the block of code it's created in, unlike a \lighttt{LoopIR.WindowExpr} created at a call site.

\filbreak
There are currently a number of problems with this (this is the situation prior to my experiments with special windows):

\begin{itemize}
  \item There isn't support for ``second order windows'' (creating a window from another window that was generated by a \lighttt{WindowStmt}).
    This crashes inside the compiler (see type system).
  \item Many scheduling rewrites (e.g. \lighttt{fission\_loop}, \lighttt{stage\_mem}) can create unsound rewrites due to not taking aliasing into account.
    See \webText{issue 594}{https://github.com/exo-lang/exo/issues/594}.
  \item Scheduling rewrites also generally don't handle taking a window from a \lighttt{WindowStmt} as input as well.
    For example, you can't stage mem using such a window as the source.
\end{itemize}

\filbreak
\mySub{Window Type System}

A window created from a \lighttt{WindowStmt} is superficially similar to a window that's a proc parameter, but really it's represented completely separately in the type system.
We have three cases, which I propose names for:

\begin{tabular}{|p{3.75cm}|p{5cm}|p{3cm}|p{3cm}|}
\hline
Proposed Name & Exo Object Code Syntax & Generated C & LoopIR type\\
\hline
\textbf{Dense Tensor} & \ \lighttt{varname: basetyp[shape]} proc parameter or alloc & Simple pointer & \ \lighttt{T.Tensor} with \lighttt{is\_window = False} \\
\hline
\textbf{Window Parameter} & \ \lighttt{varname: [basetyp][shape]} proc parameter & Window struct (pointer, strides) & \ \lighttt{T.Tensor} with \lighttt{is\_window = True} \\
\hline
\textbf{Derived Window} & \ \lighttt{dstname = srcname[slice]} (window statement) & Window struct (pointer, strides) & \ \lighttt{T.Window} with \lighttt{src\_buf = Sym} of aliased \lighttt{T.Tensor} \\
\hline
\end{tabular}

I want to point out how the \lighttt{T.Window} type, in spite of its name, in fact only represents a subset of window types: those that are created by \lighttt{WindowStmt}.
This split is responsible for many cases of the compiler crashing.
It tries to unpack a \lighttt{T.Window} as if it were a \lighttt{T.Tensor} and that causes an \lighttt{AttributeError} crash.

\filbreak
Regardless of your view of the rest of this document, if we continue with \lighttt{WindowStmt} as it exists, I think clarifying the naming and type system is \redBox{absolutely crucial}.
Not necessarily with my proposed name, but some clear vocab is needed.
% Excellent research and software comes from clarity of thought. Clarity of thought comes from clear concepts. Precise naming creates clear concepts.

\filbreak
Currently, the \lighttt{T.Window} type is needed because we statically track in the type system what is the \lighttt{Sym} of the buffer that the window aliases, and also the offsets for the window relative to the underlying aliased tensor.
This is only needed for derived windows, because window parameters can be assumed not to alias any other inputs (this is part of the usage contract for Exo).
We are supposed to use this data for soundness checks in rewrites and bounds checking.

\filbreak
\mySub{Opinion: Why David Doesn't Like WindowStmt}

Let's assume for now my new use case with \lighttt{SpecialWindow} doesn't exist.
Although I have some usability concerns for \lighttt{SpecialWindow + WindowStmt} together, for the base \lighttt{WindowStmt} feature alone, my issue isn't that window statements are confusing from a user perspective (they aren't).

\filbreak
\myKey{Implementation Effort:} \lighttt{WindowStmt} requires all scheduling operations to be aliasing-aware.
It's a restricted form of aliasing (as encoded statically in the type system) but still requires implementation effort, and more importantly, is an ongoing source of potential mistakes.

\filbreak
We want to be able to explore new extensions and ideas quickly, so I think for a research project, it's reasonable to view implementation effort as a downside.
It's not just the cost of fixing the current \lighttt{WindowStmt} bugs but the ongoing ``$O(n^2)$'' cost of language feature interaction, and the cost of all future work having to potentially be aware of this (or not be aware and cause bugs).

\filbreak
That said, I acknowledge I'm not aware of how the underlying rewrite and safety checks work, and maybe there's a simple common helper that can be implemented and used consistently everywhere to handle this.
But I still worry about mistakes from oversights ... especially since Python has no static typechecking and the \lighttt{T.Tensor} vs. \lighttt{T.Window} distinction is easy to miss.

\filbreak
\myKey{Philosophical:} There's a clear reason for \textbf{window parameters} to exist in Exo, because this is the only way to pass sub-tiles of tensors through function call boundaries.

\filbreak
I'm not convinced derived windows have any reason to exist.
Currently, they can only be created explicitly by the user in object code, or as a result of inlining a procedure call.

\filbreak
This seems like syntatic sugar, in the sense that (ignoring Exo-GPU), everything you can do with a window statement, you can do by just operating on the original tensor with offsets added to all indexing expressions.
We already have this supported as \lighttt{inline\_window}.
Which could just be rolled into \lighttt{inline\_proc} to eliminate the \lighttt{WindowStmt} entirely.

\filbreak
I feel for a USL, these sort of convenience features belong in the scheduling language, and not the underlying object code.
Now with \lighttt{SpecialWindow} and Exo-GPU, we do have a need for a concrete window-like construct supported in object code.
But I question -- if \lighttt{WindowStmt} didn't already exist -- whether we would have chosen to implement \lighttt{SpecialWindow} by creating \lighttt{WindowStmt} as it exists today.

\filbreak
\myKey{Clarity:} Having a special case in the type system for a rarely used feature is a huge risk in my opinion (as evidenced by all these bugs not being discovered by testing, even trivial things like \lighttt{AttributeError}).
Even with Exo-GPU, this will still be the case, as TMA isn't really something that typical Exo users or devs will use consistently, and although I'm trying to generalize \lighttt{CUtensorMap} to \lighttt{SpecialWindow}, in practice I doubt this pattern appears often.

\filbreak
Regardless of whether I ``should'' find the windowing system confusing, empirically, it was in fact confusing for me.
So I'm motivated to improve this situation for the next guy, either by improving the type system or eliminating \lighttt{WindowStmt} and derived windows entirely.

\filbreak
Array indexing, windowing, and dataflow (i.e. window aliasing) are core PL concepts for Exo that the group of people who are working on extending Exo all have to understand and interact with.
The costs of a confusing design are multiplied by the (growing) number of such people.
If we do keep the \lighttt{WindowStmt} and derived window around, then I think the time to think the implementation through carefully is now, \textit{before} this becomes an entrenched feature.

\filbreak
Great software comes from clarity of thought, where everyone has a clear picture of what the possible states of the system are and how their changes interact with that.
Clarity of thought comes from clear concepts.
Clear concepts are helped along greatly by clear naming.
The current special-casing situation with ``window'' \textit{sometimes} meaning \lighttt{T.Window}, sometimes not, doesn't contribute to clarity.

\end{document}
